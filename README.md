# git-practice
Я создал репозиторий, зашел в папку репозитория, где и создал файл example. После этого я создал second ветку, в ветку main я залил example.

добавил в него некоторый текст и запушил на GitHub в основную ветку main, используя команды git add ., git commit -m и git push.
Затем я создал новую ветку second branch с помощью команды git branch, переключился на нее с помощью git checkout.
После я отредактировал файл example.txt, повторил некоторые команды, описанные выше и переключился обратно в основную ветку main помощью git checkout main и слил изменения из second branch в основную ветку, используя git merge и git push.

Я создал новый текстовый файл с базовой структурой книги kniga.txt. С помощью git checkout -b создал новую ветку feature-login.
Далее я внес изменения в файл, закоммитил их и отправил ветку на GitHub, используя git add, git commit -m, git push origin.

## Работа с удаленным репозиторием
1. Я переключился на основную ветку _master_, и внес изменения в файл _kniga.txt_, закоммитил изменения и отправил их на _GitHub_ с помощью _git add_, _git commit -m_, _git push origin_.
## Моделирование конфликта
1. Я вернулся в ветку _feature-login_, изменил главу 2 в файле _kniga.txt_, закоммитил изменения и отправил их на _GitHub_, используя _git checkout_, _git add_, _git commit -m_, _git push origin_.
## Разрешение конфликта
1. Я вернулся в основную ветку _master_ и попробовал слить изменения с помощью _git checkout master_ и _git pull origin master_. Возник конфликт.
2. Я разрешил конфликт, удалив метки и оставив нужные изменения.
3. Я закоммитил решение конфликта и отправил его на _GitHub_ с помощью _git add_, _git commit -m_, _git push_.
## Автоматизация проверки формата файлов при коммите
1. Я создал _bash-script_, который будет выполнять проверку формата .txt файлов.
    ![3.png](3.png)
2. Я добавил скрипт в репозиторий, поместив его в папку _.git/hooks_ и убедившись, что у него есть права на выполнение с помощью _cp_ и _chmod +x_.
3. Далее я попробовал внести изменения и закоммитить. Теперь, при каждой попытке закоммитить изменения, Git будет автоматически выполнять проверку формата файлов перед коммитом.
4. При возникновении необходимости внести изменения в файлы, чтобы они соответствовали формату, нужно внести изменения, добавить файлы и снова попробовать закоммитить.
## Использование Git Flow в проекте
1. Сначала я проверил, есть ли у меня на компьютере _Git Flow_.
2. Затем я выполнил инициализацию _Git Flow_ в корне репозитория с помощью _git flow init_.
3. Создал ветку для новой функциональности "task-management" с помощью _git flow feature start task-management_.
4. Внес изменения в код для добавления функционала управления задачами _task_manager.py_ и выполнил коммит.
    ![4.png](4.png)
5. Потом я завершил фичу и объединил ее с основной веткой с помощью _git flow feature finish task-management_.
6. Далее я переключился на ветку _develop_ и начал создание релиза:
> git checkout develop
> 
> git flow release start v1.0.0
7. Я внес изменения, связанные с релизом:
> echo "v1.0.0" > version.txt
> 
> git add version.txt
> 
> git commit -m "Обновлена версия для релиза v1.0.0"
8. Я завершил релиз и объединил его с ветками _develop_ и _master_:
> git flow release finish v1.0.0
9. Создал _hotfix_, если в процессе использования выявлена критическая ошибка:
> git flow hotfix start hotfix-1.0.1
10. Внес изменения для исправления ошибки и закоммитил:
> git add file_with_error.py
> 
> git commit -m "Исправлена критическая ошибка"
    
![6.png](6.png)
11. Завершение _hotfix_ и объединение его с ветками _develop_ и _master_:
> git flow hotfix finish hotfix-1.0.1
12. Отправил изменения на удаленный репозиторий:
> git push origin develop
> 
> git push origin main
